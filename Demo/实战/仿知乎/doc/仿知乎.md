# 需求分析

> 项目说明与需求分析

项目说明：仿知乎问答系统

需求分析：

![1-页面整理](images/1-页面整理.png)

# 系统用例图

>  使用系统用例图梳理业务流程

![2-系统用例](images/2-系统用例.jpg)

# 整洁架构

> 使用领域驱动设计的整洁架构

参照文档《DDD基础》

整洁架构的代码分层设计：

![3-代码分层](images/3-代码分层.jpg)

# 实体类图

> 设计领域模型—确定聚合边界和实体设计

![4-实体类图](images/4-实体类图.jpg)

## 实现

**实现领域模型规范**

**实现实体基类与审计实体**

**实现用户聚合中的实体设计**

（1）用户属性中为什么没有包含用户名，密码之类的信息

因为在DDD中，用户的业务功能（关注与用户相关的业务逻辑、围绕用户的业务活动）和用户的登录/身份认证（系统安全层面，如何确保用户的身份真实性、保护用户的数据、实现用户权限的控制）通常被划分在不同聚合中。用户的登录/身份认证属于通用域，而非核心域。

**实现问答聚合中的实体设计**

**实现集成数据访问框架**

**实现数据初始化基础设施服务**

使用了Bogus框架，在测试环境下，生成种子数据

**实现审计属性自动设置**

审计属性自动设置：

- 应用代码中设置

  （1）在业务逻辑相关的处理中手动设置。这种方式会导致审计属性与业务代码紧密耦合，不易于后期维护

  （2）使用数据访问框架实现审计属性自动设置（建议）。此处使用EF Core中SaveChangesInterceptor拦截器实现

- 使用数据库特性自动设置

  缺乏灵活性，调用数据库函数实现；可能会导致并发问题；不可跨数据库迁移（因为一些数据库可能不支持时间戳特性）

**实现命令查询职责模式**

使用的框架为MediatR

读取：查询模型
写入：命令模型

可以根据各自的需求进行独立优化，从而避免因为读写操作之间潜在的冲突导致的性能瓶颈
命令用于改变领域实体的状态，因此命令操作应该依赖于领域层所提供的仓储服务
查询命令因为其只读特性，不会修改实体，所以无需依赖领域服务（此处的IQuery一般很少使用）

追加了命令（ICommand）查询（IQuery）接口到共享代码库，使其可以更直观的看出参数类型和返回类型

**实现用户注册用例和身份服务**

在用例层追加用户注册处理

**实现通用结果返回与通用仓储**

- 通用结果返回：共享类库

- 通用仓储

  仓储服务：只有聚合根才能操作管理实体。没有设计具体处理逻辑，只是对实体进行增删改查
  仓储接口：主要是限制只有聚合根才能操作管理实体。即可以放在基础层，也可以放在核心层。此处放在核心层，而仓储的实现实在基础设施层。在用例层使用仓储时，则通过依赖注入的方式。
  EFCore中的DbSet实际都是一个仓储，CellChange就是工作单元。但是如果要想实现严格的领域驱动设计，则需要使用通用的泛型接口。仓储接口是用来约束，EFCore DbSet是对外开放的，权限太大，外部可以操作任何实体。所有此处定义了仓储接口可以对仓储进行约束。

  根据整洁架构的定义，命令模型必须调用领域层的仓储服务，而查询模型则可以绕过领域层，因为它不操作实体。

**实现用户注册接口**

**实现 JWT 访问令牌**

**实现用户登录用例与接口**

**身份系统设计与改造**

问题：将用户注册和登录处理放在用例层，在架构和设计上有什么问题？
思考：用户分为身份认证系统和业务系统，身份认证系统属于基础设施。（PS：授权则是与业务系统相关的）
	将用户注册和登录处理放在用例层，会导致用户注册和用户登录与用户用例过度耦合
	用户注册其实横跨了两个系统（身份认证系统和业务系统），应该在接口层分开调用	
	用户登录整个实现与业务领域没有任何关系，所以更不应该放在用例层
改造：将用户注册和用户登录处理放在基础设施层

**实现基于令牌的身份认证**

认证协议：
基于访问访问令牌（JWT）的认证协议（客户端发）
基于Cookie的认证协议（浏览器来发、不能跨域、必须同域）

Bearer：认证方案，将令牌放在HTTP请求头部，进行传递。Authorization:Bearer JWT
Clockskew：时钟偏差。访问令牌是由身份认证中心办法，用户提交后，由于网络原因，导致Token时间有偏差。如果偏差在设置的偏差内，则认为令牌是有效的。例如令牌过期时间为12：00,时钟偏差为5min，则12：05之前令牌都是有效的。0则认为不允许有时钟偏差。在分布式系统时，可以设置一个较小的时间偏差

思考：访问令牌生成后传给客户端，假设有效期为30min，但10min登出后，服务器没有保存该访问令牌，如何吊销客户端访问令牌。
解决：将身份令牌保存到Redis中，当客户端请求时，先判断Redis是否存在，如果存在，则正常使用；如果不存在，则说明访问令牌失效

**详解MediatR管道行为模式**

**实现用户查询用例与数据查询服务**

**实现用例层授权与接口层异常处理**









第4课
问题：将用户注册和登录处理放在用例层，在架构和设计上有什么问题？
思考：
用户分为身份认证系统和业务系统，身份认证系统属于基础设施。
用户注册和用户登录与用户用例过度耦合
用户注册其实横跨了两个系统（身份认证系统和业务系统）
PS：授权则是与业务系统相关的
用户登录整个实现与业务领域没有任何关系，所以不应该放在用例层
方法：将用户注册和用户登录处理放在基础设施层

认证协议：
基于访问访问令牌（JWT）的认证协议（客户端发）
基于Cookie的认证协议（浏览器来发、不能跨域、必须同域）

Bearer：认证方案，将令牌放在HTTP请求头部，进行传递。Authorization:Bearer JWT
Clockskew：时钟偏差。访问令牌是由身份认证中心办法，用户提交后，由于网络原因，导致Token时间有偏差。如果偏差在设置的偏差内，则认为令牌是有效的。例如令牌过期时间为12：00,时钟偏差为5min，则12：05之前令牌都是有效的。0则认为不允许有时钟偏差。
在分布式系统时，可以设置一个较小的时间偏差

问题：访问令牌生成后传给客户端，有效期为30min，但登出后，服务器没有保存该访问令牌，如何吊销访问令牌。
解决：将身份令牌保存到Redis中，当客户端请求时，先判断Redis是否存在，如果存在，则正常使用；如果不存在，则说明访问令牌失效


3、授权
ASP.NET Core通过什么方式来实现用户认证和授权
管道中间件==》AOP面向切面变成的思想
用例层==》命令查询职责分离模式==》MediaR
MediaR实现了请求响应模型，也使用了管道模式，所有的请求都经过管道行为（MedieR架构图）

4、查询用例
根据用户id查询用户信息，此处使用了查询服务，没有使用仓储服务（查询模型可以绕过领域层，访问基础设施）
IReadRepository什么时候使用？
（1）命令模型中需要查询时
（2）IDataQueryService是在用例层，领域中管道实体如果需要查询则只能使用仓储


5、使用Mediat管道行为实现用例层授权与接口层异常处理
（1）为什么此处使用异常处理器IExceptionHandler而不使用异常处理器
过滤器==过滤HTTP请求和响应，更偏向处理控制器的异常
处理器==偏向处理控制器之外的异常
过滤器底层也是使用的处理器
（2）本身框架有中间件，为什么还要使用Mediat的中间件
Contrller添加的中间件与用例层是无关的，依赖由外向内，用例层（内层）不能去调用Contrller（外层）HttpAPI项目只是提供请求转发。HttpAPI项目后期也可以换成桌面程序。