10个数据结构: 数组，链表，栈，队列，散列表，二叉树，堆，跳表，图，Trie树 

10个算法： 递归，排序，二分查找，搜索，哈希算法，贪心算法，分治算法，回溯算法，动态规划，字符串匹配算法



## 时间复杂度

**引入复杂度分析的原因**

- 和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。 
- 掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。

**时间复杂度分析**

- 只关注循环执行次数最多的一段代码
- 加法法则：总复杂度等于量级最大的那段代码的复杂度：T(n)=O(max(f(n),g(n)))
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积：T(n)=O(f(n)*g(n));

**大O复杂度表示方法**

- T(n)=O(F(n)) ：T(n)代表代码执行时间，F(n)代表代码总执行次数，O表示代码执行时间与代码总执行次数成正比。 
- 大O时间复杂度代表代码执行时间随数据规模增长的变化趋势，数据规模超大时，低阶、常量、系数并不能左右增长趋势，所以只需记录最大量级即可。

**常用的几种时间复杂度**

- 多项式时间复杂度(按数量级递增) 
  - O(1) 常量阶，代码执行时间不随n增大而增大，见于无循环无递归代码，不论多少行~O(1)是一种表示方式（不论多少行）；
  - O(logN)对数阶，因为对数可以互相转换，且常量系数可忽略，所以忽略对数的底； 
  - O(n)线性阶； 
  - O(nlogN)对数线性阶；
  - 各种次方阶
- 非多项式时间复杂度：O(2的n次方) 和 O(n!)     属于非常低效的算法
-  O（m+n）与O(m*n)，代码复杂度由两个数据规模决定，由于无法得知m、n哪个量级更大，故不能直接取其一。 

**时间复杂度**

- 最好情况时间复杂度（best case time complexity）：代码在最理想情况下执行的时间复杂度。
- 最坏情况时间复杂度（worst case time complexity）：代码在最坏情况下执行的时间复杂度。
- 平均情况时间复杂度（average case time complexity）：用代码在所有情况下执行的次数的加权平均值表示。
- 均摊时间复杂度（amortized time complexity）：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有`时序关系`时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。

